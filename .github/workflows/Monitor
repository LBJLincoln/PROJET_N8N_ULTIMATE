{
  "name": "Feedback & Monitoring Ultimate - V3.0 (Production Ready) HARDENED",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag-v5-feedback",
        "options": {
          "rawBody": false
        }
      },
      "id": "259499c4-286d-4f85-aafc-6caf1b51d66f",
      "name": "Webhook Feedback",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [-700, 350]
    },
    {
      "parameters": {
        "jsCode": "// Metrics Aggregator - HARDENED with validation
const body = $node['Webhook Feedback'].json.body || {};

// Validate scores are numbers between 0-1
const validateScore = (val) => {
  const num = parseFloat(val);
  if (isNaN(num)) return 0;
  return Math.max(0, Math.min(1, num));
};

const retrievalScore = validateScore(body.retrieval_score);
const validationScore = validateScore(body.validation_score);
const docId = String(body.source_file || 'unknown').substring(0, 200);

const gap = Math.abs(validationScore - retrievalScore);

const alerts = [];
if (validationScore > 0.8 && retrievalScore < 0.5) {
  alerts.push('ALERT_PRECISION: Major correction on business data');
}
if (gap > 0.4) {
  alerts.push('ALERT_GAP: Critical confidence gap detected');
}

return {
  gap_score: Math.round(gap * 1000) / 1000,
  retrieval_reliability: retrievalScore,
  validation_feedback: validationScore,
  doc_id: docId,
  needs_fix: gap > 0.3,
  timestamp: new Date().toISOString(),
  alerts: alerts,
  alert_level: alerts.length > 0 ? 'WARNING' : 'OK'
};"
      },
      "id": "5e74b224-999d-4edc-90cd-3299676f8d9f",
      "name": "Metrics Aggregator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-480, 350]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://data.mongodb-api.com/app/data-xxxx/endpoint/data/v1/action/insertOne",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={
  "collection": "feedback_logs",
  "database": "monitoring_db",
  "dataSource": "Cluster0",
  "document": {
    "gap_score": {{ $json.gap_score }},
    "retrieval_precision": {{ $json.retrieval_reliability }},
    "faithfulness": {{ $json.validation_feedback }},
    "doc_id": "{{ $json.doc_id }}",
    "alerts": {{ JSON.stringify($json.alerts) }},
    "alert_level": "{{ $json.alert_level }}",
    "timestamp": "{{ $json.timestamp }}"
  }
}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "51368a4b-fcd8-40c1-b782-028b21600ef0",
      "name": "Store Metrics (MongoDB)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [-260, 350],
      "onError": "continueErrorOutput",
      "credentials": {
        "httpHeaderAuth": {
          "id": "MONGODB_API_CREDENTIAL_ID",
          "name": "MongoDB API Key"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.LLM_API_URL || 'https://api.openai.com/v1/chat/completions' }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={
  "model": "gpt-4-turbo",
  "messages": [
    {
      "role": "system",
      "content": "Tu es l'analyseur de derive (Data Drift) du systeme SOTA. Analyse pourquoi le score de recuperation est faible par rapport a la verite terrain. Sois concis."
    },
    {
      "role": "user",
      "content": "Analyse du gap: {{ $node['Metrics Aggregator'].json.gap_score }}. Alertes: {{ $node['Metrics Aggregator'].json.alerts.join(', ') || 'Aucune' }}"
    }
  ],
  "temperature": 0.3,
  "max_tokens": 300
}",
        "options": {
          "timeout": 20000
        }
      },
      "id": "5000395d-0977-4029-92d0-1d802687520e",
      "name": "LLM Feedback Analyzer",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [-20, 350],
      "credentials": {
        "httpHeaderAuth": {
          "id": "LLM_API_CREDENTIAL_ID",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.SLACK_WEBHOOK_URL }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={
  "text": "RAG Feedback Alert",
  "blocks": [
    {
      "type": "section",
      "text": {
        "type": "mrkdwn",
        "text": "*Alert Level:* {{ $node['Metrics Aggregator'].json.alert_level }}\
*Gap Score:* {{ $node['Metrics Aggregator'].json.gap_score }}\
*Document:* {{ $node['Metrics Aggregator'].json.doc_id }}\
*Alerts:* {{ $node['Metrics Aggregator'].json.alerts.join(', ') || 'None' }}\
*Analysis:* {{ $json.choices?.[0]?.message?.content?.substring(0, 500) || 'N/A' }}"
      }
    }
  ]
}",
        "options": {
          "timeout": 5000
        }
      },
      "id": "e240870d-6fb0-487f-b4b1-20cf30e3e5ea",
      "name": "Notify Team (Slack)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [240, 240]
    },
    {
      "parameters": {
        "jsCode": "// Shield #10: Auto-Repair Loop Breaker - ENHANCED
const metricsData = $node['Metrics Aggregator'].json;
const gapScore = metricsData.gap_score;
const docId = metricsData.doc_id;

// Pass document info for loop breaker check
return {
  gap_score: gapScore,
  doc_id: docId,
  needs_check: gapScore > 0.3 && docId && docId !== 'unknown'
};"
      },
      "id": "17e4118b-4429-4e6d-a4a8-0d1fafb28e7a",
      "name": "Auto-Repair Limiter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [240, 460]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COUNT(*) as repair_count FROM repair_history WHERE doc_id = $1 AND repair_date > NOW() - INTERVAL '24 hours'",
        "options": {}
      },
      "id": "loop-breaker-check",
      "name": "Loop Breaker Check",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [460, 460],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres Production"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Evaluate repair decision based on loop breaker
const limiterData = $node['Auto-Repair Limiter'].json;
const loopCheck = $json;
const repairCount = parseInt(loopCheck.repair_count || 0);

const MAX_REPAIRS_24H = 3;
const COOLDOWN_7D = 7 * 24 * 3600 * 1000;

if (repairCount >= MAX_REPAIRS_24H) {
  return {
    action: 'ESCALATE',
    file: limiterData.doc_id,
    reason: `Max repairs (${MAX_REPAIRS_24H}) reached in 24h - escalating to data-team`,
    gap_score: limiterData.gap_score,
    repair_count: repairCount,
    cooldown_until: new Date(Date.now() + COOLDOWN_7D).toISOString()
  };
}

if (limiterData.needs_check) {
  return {
    action: 'RE_INDEX',
    file: limiterData.doc_id,
    strategy: 'hi_res',
    reason: `Gap de confiance > 0.3 - Declenchement re-indexation WF4 (attempt ${repairCount + 1}/${MAX_REPAIRS_24H})`,
    gap_score: limiterData.gap_score,
    repair_count: repairCount
  };
} else {
  return { action: 'NONE', reason: 'No action required' };
}"
      },
      "id": "repair-decision",
      "name": "Repair Decision Evaluator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 460]
    },
    {
      "parameters": {
        "conditions": {
          "options": {"caseSensitive": true, "leftValue": "", "typeValidation": "strict"},
          "conditions": [
            {
              "id": "repair-needed",
              "leftValue": "={{ $json.action }}",
              "rightValue": "RE_INDEX",
              "operator": {"type": "string", "operation": "equals"}
            }
          ]
        }
      },
      "id": "1b7590ba-61f6-43b0-a7fb-6e9f76a64747",
      "name": "Is Repair Needed?",
      "type": "n8n-nodes-base.if",
      "position": [900, 460],
      "typeVersion": 2
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.N8N_BASE_URL }}/webhook/rag-v5-ingestion",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={
  "action": "RE_INDEX",
  "document_id": "{{ $json.file }}",
  "strategy": "{{ $json.strategy }}",
  "priority": "high",
  "reason": "{{ $json.reason }}"
}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "1fdb4c50-8d5b-49d0-b3ad-c15735d7beb6",
      "name": "Trigger WF4 - Deep Re-Indexing",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [1120, 460]
    },
    {
      "parameters": {
        "rule": {
          "interval": [{"field": "cronExpression", "expression": "0 3 * * *"}]
        }
      },
      "id": "schedule-trigger-implicit",
      "name": "Schedule Trigger (Daily Implicit Analysis)",
      "type": "n8n-nodes-base.schedule",
      "typeVersion": 1.2,
      "position": [-700, 650]
    },
    {
      "parameters": {
        "jsCode": "// Implicit Feedback Analyzer - PATCH 7.1
const conversationLogs = $input.all();

const analyzed = conversationLogs.map(log => {
  const reformulationTime = log.json.reformulation_time_seconds || 0;
  const hasExplicitFeedback = log.json.explicit_feedback !== undefined;
  
  let score = 0.8; // Default good
  let feedbackType = 'implicit';
  
  if (reformulationTime < 30 && reformulationTime > 0) {
    score = 0.2; // Bad - quick reformulation
  } else if (reformulationTime < 120 && reformulationTime > 0) {
    score = 0.5; // Medium
  }
  
  if (hasExplicitFeedback) {
    score = log.json.explicit_feedback === 'positive' ? 0.95 : 0.1;
    feedbackType = 'explicit';
  }
  
  const isGoodExample = score >= 0.75;
  const isBadExample = score <= 0.3;
  const needsReview = score > 0.3 && score < 0.75;
  
  return {
    json: {
      conversation_id: log.json.conversation_id,
      query: log.json.query,
      response: log.json.response,
      feedback_score: score,
      feedback_type: feedbackType,
      reasoning_path: log.json.reasoning_path || {},
      is_good_example: isGoodExample,
      is_bad_example: isBadExample,
      needs_review: needsReview,
      created_at: new Date().toISOString()
    }
  };
});

return analyzed;"
      },
      "id": "implicit-feedback-analyzer",
      "name": "Implicit Feedback Analyzer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-480, 650]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "rlhf_training_data",
        "columns": "conversation_id, query, response, feedback_score, feedback_type, reasoning_path, is_good_example, is_bad_example, needs_review",
        "options": {}
      },
      "id": "store-rlhf-data",
      "name": "Store RLHF Data",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [-260, 650],
      "onError": "continueErrorOutput",
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres Production"
        }
      }
    }
  ],
  "connections": {
    "Webhook Feedback": {
      "main": [[{"node": "Metrics Aggregator", "type": "main", "index": 0}]]
    },
    "Metrics Aggregator": {
      "main": [[{"node": "Store Metrics (MongoDB)", "type": "main", "index": 0}]]
    },
    "Store Metrics (MongoDB)": {
      "main": [[{"node": "LLM Feedback Analyzer", "type": "main", "index": 0}]]
    },
    "LLM Feedback Analyzer": {
      "main": [
        [{"node": "Notify Team (Slack)", "type": "main", "index": 0}],
        [{"node": "Auto-Repair Limiter", "type": "main", "index": 0}]
      ]
    },
    "Auto-Repair Limiter": {
      "main": [[{"node": "Loop Breaker Check", "type": "main", "index": 0}]]
    },
    "Loop Breaker Check": {
      "main": [[{"node": "Repair Decision Evaluator", "type": "main", "index": 0}]]
    },
    "Repair Decision Evaluator": {
      "main": [[{"node": "Is Repair Needed?", "type": "main", "index": 0}]]
    },
    "Is Repair Needed?": {
      "main": [
        [{"node": "Trigger WF4 - Deep Re-Indexing", "type": "main", "index": 0}],
        []
      ]
    },
    "Schedule Trigger (Daily Implicit Analysis)": {
      "main": [[{"node": "Implicit Feedback Analyzer", "type": "main", "index": 0}]]
    },
    "Implicit Feedback Analyzer": {
      "main": [[{"node": "Store RLHF Data", "type": "main", "index": 0}]]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "meta": {
    "instanceId": "production-sota-2026"
  }
}
