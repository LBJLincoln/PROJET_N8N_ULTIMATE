{
  "name": "Orchestrator V6.0 - Master Router [PRODUCTION] HARDENED _TestCopy",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag-v5-orchestrator",
        "options": {
          "rawBody": false
        }
      },
      "id": "webhook-entry",
      "name": "Webhook Entry Point",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.0,
      "position": [0, 400]
    },
    {
      "parameters": {
        "jsCode": "const body = $node['Webhook Entry Point'].json.body || {};
const query = String(body.query || '').trim();
const userId = String(body.user_id || 'anonymous').substring(0, 100);
const tenantId = String(body.tenant_id || 'default').substring(0, 50);
const conversationId = body.conversation_id || `conv-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
const traceId = `tr-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;

if (!query || query.length < 3) {
  throw new Error('VALIDATION_ERROR: Query must be at least 3 characters');
}

if (query.length > 2000) {
  throw new Error('VALIDATION_ERROR: Query too long (max 2000 chars)');
}

return {
  query,
  user_id: userId,
  tenant_id: tenantId,
  conversation_id: conversationId,
  trace_id: traceId,
  timestamp: new Date().toISOString(),
  ip_address: $node['Webhook Entry Point'].json.headers?.['x-forwarded-for'] || 'unknown'
};"
      },
      "id": "init-validation",
      "name": "Init & Validation (Shield #1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [200, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT entities_json, last_intent FROM conversation_context WHERE conversation_id = $1 AND tenant_id = $2 ORDER BY updated_at DESC LIMIT 1",
        "options": {}
      },
      "id": "fetch-l2-memory",
      "name": "Fetch L2 Memory",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [400, 400],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres Production"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const initData = $node['Init & Validation (Shield #1)'].json;
const memoryResult = $input.first().json;

const contextEntities = memoryResult?.entities_json || {};
const lastIntent = memoryResult?.last_intent || null;

return {
  ...initData,
  context: {
    entities: contextEntities,
    last_intent: lastIntent,
    has_memory: !!memoryResult
  }
};"
      },
      "id": "merge-context",
      "name": "Merge Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.LLM_API_URL || 'https://api.openai.com/v1/chat/completions' }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={
  "model": "{{ $vars.ROUTER_MODEL || 'gpt-4o-mini' }}",
  "messages": [
    {
      "role": "system",
      "content": "Tu es un routeur intelligent. Analyse la question et determine le type:\
- 'QUALITATIVE' pour questions conceptuelles, definitoires, explicatives\
- 'QUANTITATIVE' pour requetes SQL, metriques, KPI, agregations\
- 'GRAPH' pour relations, entites, recommandations, liens\
Reponds JSON: {\\"route\\": string, \\"reasoning\\": string, \\"confidence\\": float}"
    },
    {
      "role": "user",
      "content": "Question: {{ $json.query }}\
Contexte: {{ JSON.stringify($json.context) }}"
    }
  ],
  "temperature": 0.2,
  "max_tokens": 150,
  "response_format": { "type": "json_object" }
}",
        "options": {"timeout": 15000}
      },
      "id": "llm-router",
      "name": "LLM Router (Shield #2)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [800, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "LLM_API_CREDENTIAL_ID",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const contextData = $node['Merge Context'].json;
let routerDecision = {};
try {
  routerDecision = JSON.parse($json.choices?.[0]?.message?.content || '{}');
} catch (e) {
  routerDecision = { route: 'QUALITATIVE', confidence: 0.5, reasoning: 'Parse error - default to qualitative' };
}

const route = String(routerDecision.route || 'QUALITATIVE').toUpperCase();
const validRoutes = ['QUALITATIVE', 'QUANTITATIVE', 'GRAPH'];

if (!validRoutes.includes(route)) {
  routerDecision.route = 'QUALITATIVE';
}

return {
  ...contextData,
  routing: {
    selected: routerDecision.route,
    confidence: parseFloat(routerDecision.confidence || 0.5),
    reasoning: routerDecision.reasoning || 'N/A'
  }
};"
      },
      "id": "route-parser",
      "name": "Route Parser",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {"caseSensitive": true},
          "conditions": [
            {
              "id": "qualitative",
              "leftValue": "={{ $json.routing.selected }}",
              "rightValue": "QUALITATIVE",
              "operator": {"type": "string", "operation": "equals"}
            },
            {
              "id": "quantitative",
              "leftValue": "={{ $json.routing.selected }}",
              "rightValue": "QUANTITATIVE",
              "operator": {"type": "string", "operation": "equals"}
            },
            {
              "id": "graph",
              "leftValue": "={{ $json.routing.selected }}",
              "rightValue": "GRAPH",
              "operator": {"type": "string", "operation": "equals"}
            }
          ]
        }
      },
      "id": "route-switch",
      "name": "Route Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "workflowId": "={{ $vars.WF_RAG_CLASSIQUE_ID }}",
        "options": {}
      },
      "id": "call-rag-classique",
      "name": "Call RAG Classique (WF2)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [1400, 200]
    },
    {
      "parameters": {
        "workflowId": "={{ $vars.WF_RAG_QUANTITATIF_ID }}",
        "options": {}
      },
      "id": "call-rag-quanti",
      "name": "Call RAG Quantitatif (WF5)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "workflowId": "={{ $vars.WF_GRAPH_RAG_ID }}",
        "options": {}
      },
      "id": "call-graph-rag",
      "name": "Call Graph-RAG (WF3)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [1400, 600]
    },
    {
      "parameters": {
        "jsCode": "const routeData = $node['Route Parser'].json;
const ragResponse = $input.first().json;

return {
  status: 'SUCCESS',
  trace_id: routeData.trace_id,
  conversation_id: routeData.conversation_id,
  query: routeData.query,
  route_taken: routeData.routing.selected,
  route_confidence: routeData.routing.confidence,
  answer: ragResponse.answer || ragResponse.interpretation || 'No answer generated',
  sources: ragResponse.sources || [],
  metadata: {
    timestamp: new Date().toISOString(),
    tenant_id: routeData.tenant_id,
    user_id: routeData.user_id
  }
};"
      },
      "id": "response-aggregator",
      "name": "Response Aggregator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO conversation_context (conversation_id, tenant_id, entities_json, last_intent, updated_at) VALUES ($1, $2, $3::jsonb, $4, NOW()) ON CONFLICT (conversation_id, tenant_id) DO UPDATE SET entities_json = $3::jsonb, last_intent = $4, updated_at = NOW()",
        "options": {}
      },
      "id": "update-l2-memory",
      "name": "Update L2 Memory",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1800, 400],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres Production"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OTEL_COLLECTOR_URL || 'https://otel-collector.internal' }}/v1/traces",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={
  "traceId": "{{ $json.trace_id }}",
  "spanName": "orchestrator_complete",
  "status": "{{ $json.status }}",
  "attributes": {
    "route": "{{ $json.route_taken }}",
    "confidence": {{ $json.route_confidence }}
  }
}",
        "options": {"timeout": 5000}
      },
      "id": "otel-export",
      "name": "OTEL Export (Shield #9)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [2000, 400],
      "onError": "continueErrorOutput"
    }
  ],
  "connections": {
    "Webhook Entry Point": {
      "main": [[{"node": "Init & Validation (Shield #1)", "type": "main", "index": 0}]]
    },
    "Init & Validation (Shield #1)": {
      "main": [[{"node": "Fetch L2 Memory", "type": "main", "index": 0}]]
    },
    "Fetch L2 Memory": {
      "main": [[{"node": "Merge Context", "type": "main", "index": 0}]]
    },
    "Merge Context": {
      "main": [[{"node": "LLM Router (Shield #2)", "type": "main", "index": 0}]]
    },
    "LLM Router (Shield #2)": {
      "main": [[{"node": "Route Parser", "type": "main", "index": 0}]]
    },
    "Route Parser": {
      "main": [[{"node": "Route Switch", "type": "main", "index": 0}]]
    },
    "Route Switch": {
      "main": [
        [{"node": "Call RAG Classique (WF2)", "type": "main", "index": 0}],
        [{"node": "Call RAG Quantitatif (WF5)", "type": "main", "index": 0}],
        [{"node": "Call Graph-RAG (WF3)", "type": "main", "index": 0}]
      ]
    },
    "Call RAG Classique (WF2)": {
      "main": [[{"node": "Response Aggregator", "type": "main", "index": 0}]]
    },
    "Call RAG Quantitatif (WF5)": {
      "main": [[{"node": "Response Aggregator", "type": "main", "index": 0}]]
    },
    "Call Graph-RAG (WF3)": {
      "main": [[{"node": "Response Aggregator", "type": "main", "index": 0}]]
    },
    "Response Aggregator": {
      "main": [[{"node": "Update L2 Memory", "type": "main", "index": 0}]]
    },
    "Update L2 Memory": {
      "main": [[{"node": "OTEL Export (Shield #9)", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "active": true,
  "meta": {
    "instanceId": "production-sota-2026"
  }
}
