{
  "name": "RAG Quantitatif V1.0 - Text-to-SQL Deterministe (SOTA 2026) HARDENED",
  "nodes": [
    {
      "parameters": {},
      "id": "quanti-trigger",
      "name": "Sub-Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [0, 200]
    },
    {
      "parameters": {
        "jsCode": "// Init & ACL for Quantitative RAG - HARDENED
const input = $input.first().json;
const userContext = input.user_context || {};

// Validation
if (!input.query) {
  throw new Error('VALIDATION_ERROR: query is required');
}

return {
  trace_id: input.trace_id || `tr-quant-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`,
  query: String(input.query).substring(0, 2000).trim(),
  user_context: {
    tenant_id: userContext.tenant_id || 'default',
    groups: userContext.groups || ['guest']
  },
  timestamp: new Date().toISOString()
};"
      },
      "id": "init-acl-quanti",
      "name": "Init & ACL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [200, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT table_name, column_name, data_type, is_nullable FROM information_schema.columns WHERE table_schema = 'public' AND table_name IN ('sales', 'products', 'customers', 'orders', 'transactions') ORDER BY table_name, ordinal_position",
        "options": {"timeout": 10000}
      },
      "id": "schema-introspection",
      "name": "Schema Introspection",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [400, 200],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres Production"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build schema context for LLM
const schemaData = $input.all().map(i => i.json);
const tables = {};

schemaData.forEach(col => {
  if (!tables[col.table_name]) tables[col.table_name] = [];
  tables[col.table_name].push(`${col.column_name} ${col.data_type}${col.is_nullable === 'NO' ? ' NOT NULL' : ''}`);
});

const schemaContext = Object.entries(tables)
  .map(([table, columns]) => `Table: ${table}\
Columns: ${columns.join(', ')}`)
  .join('\
\
');

const initData = $node['Init & ACL'].json;

return {
  ...initData,
  schema_context: schemaContext,
  available_tables: Object.keys(tables)
};"
      },
      "id": "schema-context-builder",
      "name": "Schema Context Builder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.LLM_API_URL || 'https://api.openai.com/v1/chat/completions' }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{
  "model": "{{ $vars.SQL_MODEL || 'gpt-4o' }}",
  "messages": [
    {
      "role": "system",
      "content": "Tu es un expert SQL. Genere une requete SQL PostgreSQL VALIDE et SECURISEE basee sur la question utilisateur et le schema fourni. REGLES CRITIQUES:\
1. Toujours commencer par SELECT\
2. Toujours inclure LIMIT (max 1000)\
3. Toujours filtrer par tenant_id = '{{ $json.user_context.tenant_id }}'\
4. Jamais de DELETE, UPDATE, INSERT, DROP, TRUNCATE, ALTER, CREATE\
5. Jamais de commentaires SQL (--)\
6. Reponds JSON: {\\"sql\\": string, \\"explanation\\": string}"
    },
    {
      "role": "user",
      "content": "Question: {{ $json.query }}\
\
Schema disponible:\
{{ $json.schema_context }}"
    }
  ],
  "temperature": 0.1,
  "max_tokens": 500,
  "response_format": { "type": "json_object" }
}",
        "options": {"timeout": 25000}
      },
      "id": "text-to-sql-generator",
      "name": "Text-to-SQL Generator (LLM)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [800, 200],
      "credentials": {
        "httpHeaderAuth": {
          "id": "LLM_API_CREDENTIAL_ID",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// CRITICAL: SQL Validator - Security Shield
const contextData = $node['Schema Context Builder'].json;
let llmResponse = {};
try {
  llmResponse = JSON.parse($json.choices?.[0]?.message?.content || '{}');
} catch (e) {
  throw new Error('SQL_GENERATION_ERROR: Invalid LLM response');
}

const sql = String(llmResponse.sql || '').toUpperCase().trim();

// FORBIDDEN PATTERNS - P0 Security
const forbiddenPatterns = [
  /DELETE|UPDATE|INSERT|DROP|TRUNCATE|ALTER|CREATE/i,
  /GRANT|REVOKE|EXEC|EXECUTE|CALL/i,
  /--|;.*;|UNION.*SELECT/i,
  /xp_|sp_|pg_sleep/i,
  /\\bINTO\\s+OUTFILE\\b|\\bLOAD_FILE\\b/i
];

for (const pattern of forbiddenPatterns) {
  if (pattern.test(sql)) {
    throw new Error(`SQL_INJECTION_DETECTED: Forbidden pattern detected - ${pattern.source}`);
  }
}

// REQUIRED PATTERNS
if (!sql.startsWith('SELECT')) {
  throw new Error('SQL_VALIDATION_ERROR: Query must start with SELECT');
}

if (!sql.includes('LIMIT')) {
  throw new Error('SQL_VALIDATION_ERROR: Query must include LIMIT clause');
}

// Extract LIMIT value
const limitMatch = sql.match(/LIMIT\\s+(\\d+)/i);
if (limitMatch) {
  const limitValue = parseInt(limitMatch[1]);
  if (limitValue > 1000) {
    throw new Error('SQL_VALIDATION_ERROR: LIMIT must be <= 1000');
  }
}

// Check tenant_id filter
if (!sql.includes('TENANT_ID')) {
  throw new Error('SQL_VALIDATION_ERROR: Query must include tenant_id filter');
}

// Passed validation
return {
  ...contextData,
  validated_sql: llmResponse.sql,
  explanation: llmResponse.explanation,
  validation_status: 'PASSED',
  validation_timestamp: new Date().toISOString()
};"
      },
      "id": "sql-validator",
      "name": "SQL Validator (Shield #1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.validated_sql }}",
        "options": {"timeout": 30000}
      },
      "id": "sql-executor",
      "name": "SQL Executor (Postgres)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1200, 200],
      "onError": "continueErrorOutput",
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres Production"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for interpretation
const validatorData = $node['SQL Validator (Shield #1)'].json;
const sqlResults = $input.all().map(i => i.json);

if (sqlResults.length === 0) {
  return {
    ...validatorData,
    sql_results: [],
    result_count: 0,
    has_results: false
  };
}

return {
  ...validatorData,
  sql_results: sqlResults,
  result_count: sqlResults.length,
  has_results: true,
  result_preview: JSON.stringify(sqlResults.slice(0, 5), null, 2)
};"
      },
      "id": "result-aggregator",
      "name": "Result Aggregator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1400, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.LLM_API_URL || 'https://api.openai.com/v1/chat/completions' }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{
  "model": "{{ $vars.DEFAULT_LLM_MODEL || 'gpt-4-turbo' }}",
  "messages": [
    {
      "role": "system",
      "content": "Tu es un analyste financier expert. Interprete les resultats SQL et reponds a la question initiale de maniere claire et concise. Si les donnees sont vides, explique pourquoi."
    },
    {
      "role": "user",
      "content": "Question initiale: {{ $json.query }}\
\
Requete SQL executee: {{ $json.validated_sql }}\
\
Resultats ({{ $json.result_count }} lignes):\
{{ $json.result_preview }}"
    }
  ],
  "temperature": 0.3,
  "max_tokens": 800
}",
        "options": {"timeout": 25000}
      },
      "id": "interpretation-layer",
      "name": "Interpretation Layer (LLM Analyst)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [1600, 200],
      "credentials": {
        "httpHeaderAuth": {
          "id": "LLM_API_CREDENTIAL_ID",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Response Formatter
const aggregatorData = $node['Result Aggregator'].json;
const interpretation = $json.choices?.[0]?.message?.content || 'No interpretation available';

return {
  status: 'SUCCESS',
  trace_id: aggregatorData.trace_id,
  query: aggregatorData.query,
  sql_executed: aggregatorData.validated_sql,
  result_count: aggregatorData.result_count,
  interpretation: interpretation,
  raw_results: aggregatorData.has_results ? aggregatorData.sql_results : [],
  metadata: {
    validation_status: aggregatorData.validation_status,
    timestamp: new Date().toISOString(),
    engine: 'QUANTITATIVE'
  }
};"
      },
      "id": "response-formatter",
      "name": "Response Formatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.OTEL_COLLECTOR_URL || 'https://otel-collector.internal' }}/v1/traces",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={
  "traceId": "{{ $json.trace_id }}",
  "spanName": "quantitative_rag_complete",
  "status": "{{ $json.status }}",
  "attributes": {
    "result_count": {{ $json.result_count }},
    "sql_length": {{ $json.sql_executed?.length || 0 }}
  }
}",
        "options": {"timeout": 5000}
      },
      "id": "otel-export",
      "name": "OTEL Export (Shield #9)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [2000, 200],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {},
      "id": "error-trigger",
      "name": "Error Handler",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "jsCode": "// Error handler for SQL validation/execution errors
const error = $json;
const initData = $node['Init & ACL']?.json || {};

return {
  status: 'ERROR',
  trace_id: initData.trace_id,
  error_type: error.message?.includes('SQL_') ? 'SQL_ERROR' : 'SYSTEM_ERROR',
  error_message: error.message || 'Unknown error',
  timestamp: new Date().toISOString()
};"
      },
      "id": "error-handler",
      "name": "Error Response Builder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 400]
    }
  ],
  "connections": {
    "Sub-Workflow Trigger": {
      "main": [[{"node": "Init & ACL", "type": "main", "index": 0}]]
    },
    "Init & ACL": {
      "main": [[{"node": "Schema Introspection", "type": "main", "index": 0}]]
    },
    "Schema Introspection": {
      "main": [[{"node": "Schema Context Builder", "type": "main", "index": 0}]]
    },
    "Schema Context Builder": {
      "main": [[{"node": "Text-to-SQL Generator (LLM)", "type": "main", "index": 0}]]
    },
    "Text-to-SQL Generator (LLM)": {
      "main": [[{"node": "SQL Validator (Shield #1)", "type": "main", "index": 0}]]
    },
    "SQL Validator (Shield #1)": {
      "main": [[{"node": "SQL Executor (Postgres)", "type": "main", "index": 0}]]
    },
    "SQL Executor (Postgres)": {
      "main": [[{"node": "Result Aggregator", "type": "main", "index": 0}]]
    },
    "Result Aggregator": {
      "main": [[{"node": "Interpretation Layer (LLM Analyst)", "type": "main", "index": 0}]]
    },
    "Interpretation Layer (LLM Analyst)": {
      "main": [[{"node": "Response Formatter", "type": "main", "index": 0}]]
    },
    "Response Formatter": {
      "main": [[{"node": "OTEL Export (Shield #9)", "type": "main", "index": 0}]]
    },
    "Error Handler": {
      "main": [[{"node": "Error Response Builder", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "active": true,
  "meta": {
    "instanceId": "production-sota-2026"
  }
}
